---
phase: 07-blog-discovery-sharing
plan: 03
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/pages/blog/[...page].astro
autonomous: true

must_haves:
  truths:
    - "User can type in search input and see blog posts filtered in real time"
    - "User can click category/tag filter pills to narrow down posts"
    - "Search and filter results show posts from ALL pages, not just current paginated page"
    - "Pagination hides when search/filters are active"
    - "'Showing X posts' count updates in real time with search/filters"
    - "'No posts found' message shows with a clear filters button when results are empty"
    - "URL updates with search/filter query params for shareable filtered views"
    - "Page load restores search/filter state from URL params"
    - "Search highlights matching terms in post titles"
  artifacts:
    - path: "src/pages/blog/[...page].astro"
      provides: "Blog listing page with integrated search, filtering, and dynamic results"
      contains: "BlogDiscoveryBar"
  key_links:
    - from: "src/pages/blog/[...page].astro"
      to: "/api/posts.json"
      via: "fetch in client-side script"
      pattern: "fetch.*api/posts\\.json"
    - from: "src/pages/blog/[...page].astro"
      to: "fuse.js"
      via: "import for client-side search"
      pattern: "import Fuse"
    - from: "src/pages/blog/[...page].astro"
      to: "src/components/blog/BlogDiscoveryBar.astro"
      via: "component import"
      pattern: "import BlogDiscoveryBar"
    - from: "src/pages/blog/[...page].astro"
      to: "history.replaceState"
      via: "URL state sync on search/filter change"
      pattern: "history\\.replaceState"
---

<objective>
Wire the BlogDiscoveryBar into the blog listing page with full client-side search (Fuse.js), filter pill interactivity, dynamic result rendering, URL state synchronization, and empty state handling.

Purpose: This is the core integration plan that makes search and filtering actually work. Plan 01 created the data (JSON endpoint) and UI (discovery bar component). This plan connects them with client-side JavaScript to create a fully interactive discovery experience.

Output: The blog listing page at `/blog` with working real-time search, clickable filter pills, dynamic results from JSON index, URL state sync, and proper empty/loading states.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-blog-discovery-sharing/07-CONTEXT.md
@.planning/phases/07-blog-discovery-sharing/07-RESEARCH.md
@.planning/phases/07-blog-discovery-sharing/07-01-SUMMARY.md

@src/pages/blog/[...page].astro
@src/components/blog/BlogDiscoveryBar.astro
@src/pages/api/posts.json.ts
@src/components/blog/PostCard.astro
@src/components/blog/PostListRow.astro
@src/components/blog/Pagination.astro
@src/data/services.ts
@src/utils/formatDate.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate BlogDiscoveryBar and build client-side search/filter engine</name>
  <files>src/pages/blog/[...page].astro</files>
  <action>
Modify `src/pages/blog/[...page].astro` to add the discovery bar and a full client-side search/filter system.

**Frontmatter changes:**
1. Add imports:
   - `import BlogDiscoveryBar from "@components/blog/BlogDiscoveryBar.astro";`
   - Collect unique tags from all posts: query `getCollection("blog")` to extract all unique tags
   - Build categories array from services data: `import { services } from "@/data/services";`
   - Pass categories and tags as props to BlogDiscoveryBar

**Template changes:**
1. Insert `<BlogDiscoveryBar>` between the subtitle paragraph and the post grid, passing categories (as {slug, title} objects) and tags (string array of unique tags from all posts)

2. Wrap the existing grid section, list section, and pagination in a container div with class `blog-server-content` (this is the server-rendered paginated view)

3. Add a new container div with class `blog-client-results hidden` that will hold dynamically rendered search/filter results. This div should contain:
   - A results container: `<div class="blog-results-grid mb-12 grid grid-cols-1 gap-6 md:grid-cols-2 lg:grid-cols-3"></div>`
   - A "no results" message (hidden by default): `<div class="no-results hidden text-center py-12"><p class="text-surface-500 dark:text-surface-400 mb-4">No posts found matching your search.</p><button class="clear-filters-btn rounded-full bg-accent-500 px-6 py-2 text-sm font-medium text-surface-50 transition-colors hover:bg-accent-600">Clear filters</button></div>`

4. Add the Pagination wrapper div a class `blog-pagination` for JS targeting

**Client-side `<script>` tag (the main integration script):**

This script is the heart of the search/filter system. It must:

a) **Initialize on page load** using both `DOMContentLoaded` and `astro:page-load` for View Transitions safety (per 03-03 decision pattern). Use a single `init()` function called from both events.

b) **Fetch search index**: `fetch("/api/posts.json")` on init, parse as JSON into `allPosts` array.

c) **Initialize Fuse.js**:
   ```typescript
   import Fuse from "fuse.js";
   const fuse = new Fuse(allPosts, {
     keys: [
       { name: "title", weight: 2 },
       { name: "excerpt", weight: 1 },
       { name: "tags", weight: 1.5 },
     ],
     threshold: 0.3,
     includeMatches: true,
     minMatchCharLength: 2,
   });
   ```

d) **Search input handler**: Add `input` event listener on `[data-search-input]` with 250ms debounce. On input, call `applyFilters()`.

e) **Filter pill click handler**: Add click listeners on all `.filter-pill` elements.
   - "All" pill (`[data-filter="all"]`): Clear all active filters, reset search input, show server content.
   - Category/tag pills: Toggle active state. Active = `bg-accent-500 text-surface-50`, remove inactive classes. When a non-"All" pill is clicked, deactivate the "All" pill. When no pills are active (all deselected), re-activate "All" pill.
   - Multi-select: multiple pills can be active simultaneously (AND logic).
   - After toggling, call `applyFilters()`.

f) **`applyFilters()` function** -- the core logic:
   1. Read current search query from input
   2. Read active filter pills (collect `data-filter` values, excluding "all")
   3. Determine if filtering is active (`query.trim() || activeFilters.length > 0`)
   4. If NOT filtering: show `.blog-server-content`, hide `.blog-client-results`, clear results count. Return.
   5. If filtering: hide `.blog-server-content`, show `.blog-client-results`
   6. Get results: start with Fuse.js search if query exists, otherwise start with all posts
   7. Apply AND filter logic: for each active filter, check if post's `category === filter` OR `post.tags.includes(filter)`. Post must match ALL active filters. Research open question resolved: since a post has only one category, selecting two categories via AND will return zero results. This is correct behavior -- the "Showing 0 posts" count makes this clear, and the "All" pill provides easy reset.
   8. Render results into `.blog-results-grid` as HTML cards (simplified card markup matching PostCard style: link, title, category badge, date)
   9. Apply search highlighting: wrap matching substrings in title with `<mark class="bg-accent-100 dark:bg-accent-800/50 px-0.5 rounded">` tags
   10. Update results count: `"Showing X posts"` (or `"Showing X post"` for singular)
   11. Toggle `.no-results` visibility based on results length
   12. Call `updateUrlState()`

g) **`updateUrlState()` function**: Sync search query and active filters to URL params using `history.replaceState`. Pattern:
   - `q` param for search query (delete if empty)
   - `category` params for active category filters (use `append` for multiple)
   - `tag` params for active tag filters (use `append` for multiple)

h) **`restoreStateFromUrl()` function**: On init, read URL params and restore:
   - Set search input value from `q` param
   - Activate pills matching `category` and `tag` params
   - Call `applyFilters()` if any state was restored

i) **`highlightMatch()` utility**: Takes text and query, returns HTML string with matching substrings wrapped in `<mark>` tags. Escape regex special chars in query. Only apply to plain text, never raw HTML.

j) **`renderPostCard()` helper**: Generates HTML string for a single post result card. Must match the visual structure of the server-rendered PostCard:
   - Link to `/blog/${post.id}/`
   - Category badge (using `categoryTitle` field)
   - Title (with highlight if search query active)
   - Date (formatted -- use simple date formatting since `formatPostDate` is server-side; for client-rendered cards, use `new Date(post.date).toLocaleDateString("en-US", { year: "numeric", month: "long", day: "numeric" })`)
   - Note: no featured image in client-rendered cards (the JSON index doesn't include image paths, and that's fine -- keeps the index small)

k) **Clear filters button**: The `.clear-filters-btn` in the no-results message should reset all filters and search, reactivate "All" pill, and show server content.

l) **Debounce utility**: Inline 3-line debounce function (per RESEARCH.md -- no library needed).

**Important implementation notes:**
- Use class selectors everywhere, never IDs (03-03 decision)
- The script must be a module script: `<script>` (not `<script is:inline>`) so Fuse.js import works
- When no search/filters active, the page looks identical to before -- same server-rendered cards and pagination
- When search/filters ARE active, pagination hides and results come from the JSON index (all posts, not just current page)
  </action>
  <verify>
1. `npm run build` succeeds
2. `npm run dev` -- visit `/blog`:
   - Discovery bar visible with search input and filter pills
   - Type in search box -- results filter in real time
   - Click a category pill -- posts filter to that category
   - Click multiple pills -- AND logic narrows results
   - "Showing X posts" count updates
   - Pagination disappears when filtering
   - Click "All" pill -- returns to normal paginated view
   - Empty search shows "No posts found" with clear button
3. Check URL updates with ?q= and ?category= params when filtering
4. Reload page with filter params in URL -- state restores correctly
  </verify>
  <done>
Blog listing page has fully functional real-time search via Fuse.js, clickable filter pills with AND logic, dynamic client-side result rendering from JSON index, pagination hiding during filtered view, "Showing X posts" counter, "No posts found" empty state with clear button, URL state sync via replaceState, and state restoration from URL params on page load.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` completes without errors
2. Search works: typing "outdoor" shows matching posts
3. Category filter works: clicking "Weddings" pill shows only wedding posts
4. Tag filter works: clicking a tag pill filters by that tag
5. AND logic: selecting category + tag narrows results to posts matching both
6. Empty state: search for nonsense shows "No posts found" + clear button
7. Results count: "Showing X posts" updates in real time
8. Pagination: hidden during search/filter, visible when no filters active
9. URL state: filtering updates URL params, page reload restores state
10. Search highlighting: matching terms highlighted in post titles
</verification>

<success_criteria>
- User can search blog content in real time via Fuse.js fuzzy search
- User can filter by clicking category/tag pills with AND logic
- Results come from full JSON index (all posts across all pages)
- Pagination hides during filtered view, shows during normal view
- URL updates with filter/search params for shareable filtered views
- Empty state with clear filters button when no results match
- Page load restores state from URL params
</success_criteria>

<output>
After completion, create `.planning/phases/07-blog-discovery-sharing/07-03-SUMMARY.md`
</output>
